#!/usr/bin/env python3
# coding=utf-8
#
import os
import re
import sys
import time
import psutil
import argparse

# ------------------------------------------------------------------------------
class AnnotateArgumentParser(argparse.ArgumentParser):
    # --------------------------------------------------------------------------
    def _nonnegative_int(self, x):
        try:
            i = int(x)
            assert(i > 0)
            return i
        except:
            self.error("`%s' is not a positive integer value" % str(x))
    # --------------------------------------------------------------------------
    def __init__(self, **kw):
        argparse.ArgumentParser.__init__(self, **kw)

        self.add_argument(
            "--separator", "-s",
            dest='separator',
            default='|',
            action="store"
        )

        self.add_argument(
            "--init-counter", "-c",
            nargs='?',
            dest="counter",
            type=self._nonnegative_int,
            default=0,
            action="store"
        )

        self.add_argument(
            "--format", "-f",
            dest='format_str',
            default=None,
            action="store"
        )
    # --------------------------------------------------------------------------
    def process_parsed_options(self, options):
        options.format_args = re.findall("%\((\w+)\)", options.format_str)
        return options
    # --------------------------------------------------------------------------
    def parse_args(self):
        return self.process_parsed_options(
            argparse.ArgumentParser.parse_args(self)
        )

# ------------------------------------------------------------------------------
def make_argparser():
	return AnnotateArgumentParser(
            prog=os.path.basename(__file__),
            description="""
            Utility annotating lines read from standard input
		"""
	)

# ------------------------------------------------------------------------------
class StatusGetter(object):
    # --------------------------------------------------------------------------
    def _update(self):
        for t, la in zip([1, 5, 15], psutil.getloadavg()):
            self._cache["cpu_load_%d" % t] = float(la)

    # --------------------------------------------------------------------------
    def _get(self, name, options):
        try:
            return self._getters[name](options)
        except KeyError:
            return self._cache[name]

    # --------------------------------------------------------------------------
    def __init__(self):
        self._getters = {
            "count": lambda o: o.counter,
            "cpu_perc": lambda o: psutil.cpu_percent(),
            "cpu_freq": lambda o: psutil.cpu_freq().current,
            "mem_total": lambda o: psutil.virtual_memory().total,
            "mem_used": lambda o: psutil.virtual_memory().used,
            "mem_free": lambda o: psutil.virtual_memory().free,
            "mem_avail": lambda o: psutil.virtual_memory().available,
            "swap_total": lambda o: psutil.swap_memory().total,
            "swap_used": lambda o: psutil.swap_memory().used,
            "swap_free": lambda o: psutil.swap_memory().free,
            "swap_perc": lambda o: psutil.swap_memory().percent,
            "batt_perc": lambda o: psutil.sensors_battery().percent,
            "age": lambda o: time.time() - o.start_time
        }

        self._cache = {}
        self._update()

    # --------------------------------------------------------------------------
    def get(self, options):
        self._update()
        return {arg: self._get(arg, options) for arg in options.format_args}

# ------------------------------------------------------------------------------
def annotation(line, options):
    return options.format_str % options.getter.get(options)

# ------------------------------------------------------------------------------
def main():
    """ The main entry point.
    """

    options = make_argparser().parse_args()
    options.getter = StatusGetter()
    options.start_time = time.time()

    try:
        while True:
            line = sys.stdin.readline()
            if line is None: break
            sys.stdout.write(annotation(line, options))
            sys.stdout.write(options.separator)
            sys.stdout.write(line)
            options.counter += 1
    except KeyboardInterrupt:
        pass

    return 0

# ------------------------------------------------------------------------------
if __name__ == "__main__":
    sys.exit(main())

